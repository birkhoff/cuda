/**
 * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
 *
 * Please refer to the NVIDIA end user license agreement (EULA) associated
 * with this source code for terms and conditions that govern your use of
 * this software. Any use, reproduction, disclosure, or distribution of
 * this software and related documentation outside the terms of the EULA
 * is strictly prohibited.
 */
#include <stdio.h>
#include <stdlib.h>

static const int WORK_SIZE = 256;

/**
 * This macro checks return value of the CUDA runtime call and exits
 * the application if the call failed.
 */
#define CUDA_CHECK_RETURN(value) {											\
	cudaError_t _m_cudaStat = value;										\
	if (_m_cudaStat != cudaSuccess) {										\
		fprintf(stderr, "Error %s at line %d in file %s\n",					\
				cudaGetErrorString(_m_cudaStat), __LINE__, __FILE__);		\
		exit(1);															\
	} }

__device__ unsigned int bitreverse(unsigned int number) {
	number = ((0xf0f0f0f0 & number) >> 4) | ((0x0f0f0f0f & number) << 4);
	number = ((0xcccccccc & number) >> 2) | ((0x33333333 & number) << 2);
	number = ((0xaaaaaaaa & number) >> 1) | ((0x55555555 & number) << 1);
	return number;
}

/**
 * CUDA kernel function that reverses the order of bits in each element of the array.
 */
__global__ void bitreverse(void *data) {
	unsigned int *idata = (unsigned int*) data;
	idata[threadIdx.x] = bitreverse(idata[threadIdx.x]);
}


__global__ void multiply(int *a, int *b, int *c)
{
	//c[blockIdx.x] = a[blockIdx.x] + b[blockIdx.x];
	int index = threadIdx.x + blockIdx.x * blockDim.x;

	c[index] += a[index] * b[index];
}

/**
 * Host function that prepares data array and passes it to the CUDA kernel.
 */
int main(int argc, char *argv[]) {

	struct timeval t0;
	struct timeval t1;

	int a_r = atoi(argv[1]);				// count of rows from A
	int a_c = atoi(argv[2]);				// column from A

	int b_r = atoi(argv[3]);				// count of rows from B
	int b_c = atoi(argv[4]);				// column from B

	if(a_c != b_r)	return -1;

	int *a, *b, *c; 					// host copies of a, b, c
	int *d_a, *d_b, *d_c; 				// device copies of a, b, c
	//	int size = i * sizeof(int);

	a = (int *)malloc(a_r*a_c * sizeof(int));
	b = (int *)malloc(b_r*b_c * sizeof(int));
	c = (int *)malloc(a_r*b_c* sizeof(int));

	for (int i = 0; i < nDevices; i++) {
	    cudaDeviceProp prop;
	    cudaGetDeviceProperties(&prop, i);
	    printf("  Device Number: %d\n", i);
	    printf("  Device name: %s\n", prop.name);
	    printf("  Memory Clock Rate (KHz): %d\n",
	           prop.memoryClockRate);
	    printf("  Memory Bus Width (bits): %d\n",
	           prop.memoryBusWidth);
	    printf("  Peak Memory Bandwidth (GB/s): %f\n",
	           2.0*prop.memoryClockRate*(prop.memoryBusWidth/8)/1.0e6);
	    printf("  Max Threads Per Block: %d\n\n",prop.maxThreadsPerBlock);
	}



	int i = 0;
	int j = 0;

	for(i =0; i < a_r; i++)
	{
		for(j=0; j < a_c; j++)
		{
			a[i] = 1;		//rand() % 100;
		}
	}

	for(i=0; i < b_r; i++)
	{
		for(j=0; j < b_c; j++)
		{
			b[i] = 1;		//rand() % 100;

		}
	}

	for(i=0; i < a_r; i++)
	{
		for(j= 0; j < b_c; j++)
		{
			c[i] = 0;
		}
	}


	return 0;
}
